
import java.io.*;
import java.util.*;

public class Trie {

    // node class
    private static class TrieNode {

        boolean isWord;
        HashMap<Character, TrieNode> children = new HashMap<
            Character,
            TrieNode
        >();
    }

    // root node
    private TrieNode root = new TrieNode();

    //takes a target string and distance, creates a hashmap of all words within that distance 
    //of the target string
    private void recursiveCheck(int k, String target, TrieNode trie, HashMap<String, Integer> wordMap, String newWord, int idx, int dist){
        //System.out.println("recurring");
        Trie.TrieNode current = trie;
        //end of that branch, return
        if (current == null){
            return;
        }
        
        //System.out.println(newWord);
        // if (k == 4){
        //     System.out.println(newWord);
        //     System.out.println("working");
        // }
        //System.out.println(current.isWord);
        String alphabet = "abcdefghijklmnopqrstuvwxyz";
        //add to wordmap
        // if (target.length() - idx <= k) then I need to add it to dist-k when i put the value in there
        //I also need to modify this wordMap.get(newWord) > dist - k
        // if (current != null && current.isWord){
        //     if (target.length() - idx - 1 <=k){
        //         if (!(wordMap.containsKey(newWord))){
        //             wordMap.put(newWord, dist-k);
        //         }
        //         else if (wordMap.get(newWord) > dist - k){
        //             wordMap.put(newWord, dist-k + target.length() - idx-1 );
        //         }
        //     }
        //     else{
        //         if (!(wordMap.containsKey(newWord))){
        //             wordMap.put(newWord, dist-k);
        //         }
        //         else if (wordMap.get(newWord) > dist - k){
        //             wordMap.put(newWord, dist-k + target.length() - idx - 1);
        //         }
        //     }
        // }
      
        if (target.length() - idx <= k && current != null && current.isWord){
            System.out.println(newWord);
            System.out.println(dist - k);
            if ((!(wordMap.containsKey(newWord)) || wordMap.get(newWord) > dist - k + target.length() - idx)){
                System.out.println("first if statement");
                System.out.println(target.length() + " " + idx + " " + k + " " + dist + " " + newWord);
                
                wordMap.put(newWord, dist-k + target.length() - idx);
            }
            
        }
        // if (current != null && current.isWord){
        //     if ((!(wordMap.containsKey(newWord)) || wordMap.get(newWord) > dist - k)){
        //         wordMap.put(newWord, dist-k);
        //     }
           
        // }
       
        if (k>0){
            //Deletion:
            if (idx < target.length()){
                //System.out.println("deletion check");
                recursiveCheck(k-1, target, current, wordMap, newWord, idx + 1, dist);
            }
            
            
            //Insertion:
            
                //System.out.println("insertion check");
                for (int i = 0; i < alphabet.length(); i++) {
                    //System.out.println(alphabet.charAt(i));
                    char c = alphabet.charAt(i);
                    TrieNode child = current.children.get(c);
                    recursiveCheck(k-1, target, child, wordMap, newWord+c, idx, dist);
                }
    
            
            //Substitution:
            if (idx < target.length()){
            for (int i = 0; i < alphabet.length(); i++){
                char c = alphabet.charAt(i);
                //System.out.println("substitution check");
                //System.out.println(alphabet.charAt(i));
                if (current != null){
                    TrieNode child = current.children.get(c);
                    if (child != null && idx < target.length()){
                        if (alphabet.charAt(i) == target.charAt(idx)){
                            recursiveCheck(k, target, child, wordMap, newWord+c, idx+1, dist);
                            }
                        else{
                            recursiveCheck(k-1,target, child, wordMap, newWord+c, idx+1, dist);
                            }
                    }
                }
                
                }
        }
            }
            if (idx < target.length()){
                if (k == 0){
                //System.out.println("final check");
                for (int i = 0; i < alphabet.length(); i++){
                    char c = alphabet.charAt(i);
                    //System.out.println(alphabet.charAt(i));
                    if (alphabet.charAt(i) == target.charAt(idx)){
                        if (current != null){
                            TrieNode child = current.children.get(c);
                            if (child != null && idx < target.length()){
                        recursiveCheck(k, target, current.children.get(c), wordMap, newWord+c, idx+1, dist);
                            }
                        }
                    //System.out.println(wordMap);
                    }
                //return wordMap;
            }
    }}
            
}

    // method to implement
    public HashMap<String, Integer> suggestions(String target, int dist) {
        HashMap<String, Integer> words = new HashMap<String, Integer>();
        recursiveCheck(dist, target, root, words, "", 0, dist);
        return words;
    }

    // method to add a string
    public boolean add(String s) {
        s = s.trim().toLowerCase();

        TrieNode current = root;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isLowerCase(c)) {
                TrieNode child = current.children.get(c);
                if (child == null) {
                    child = new TrieNode();
                    current.children.put(c, child);
                }
                current = child;
            }
        }

        if (current.isWord) return false;

        current.isWord = true;
        return true;
    }

    // method to check if a string has been added
    public boolean contains(String s) {
        s = s.trim().toLowerCase();

        TrieNode current = root;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isLowerCase(c)) {
                TrieNode child = current.children.get(c);
                if (child == null) {
                    return false;
                }
                current = child;
            }
        }

        return current.isWord;
    }

    // empty constructor
    public Trie() {
        super();
    }

    // constructor to add words from a stream, like standard input
    public Trie(InputStream source) {
        Scanner scan = new Scanner(source);
        addWords(scan);
        scan.close();
    }

    // constructor to add words from a file
    public Trie(String filename) throws FileNotFoundException {
        Scanner scan = new Scanner(new File(filename));
        addWords(scan);
        scan.close();
    }

    // helper function to add words from a scanner
    private void addWords(Scanner scan) {
        while (scan.hasNext()) {
            add(scan.next());
        }
    }

    // main function for testing
    public static void main(String[] args) throws FileNotFoundException{
        Trie dictionary;

        // the following section of code is set up
        // to read the filename from a command-line argument
        //
        // if you prefer to hard-code a filename for testing
        // or add words to the Trie manually, comment this section
        
        // if (args.length > 0) {
        //     try {
        //         dictionary = new Trie(args[0]);
        //     } catch (FileNotFoundException e) {
        //         System.err.printf(
        //             "could not open file %s for reading\n",
        //             args[0]
        //         );
        //         return;
        //     }
        // } else {
        //     dictionary = new Trie(System.in);
        // }
        
        // here is an example of hard-coding the filename
        // making it easier to use the "Run" button in VS Code
       
        
       // dictionary = new Trie("ospd.txt");
        

        // here is an example of adding words to the Trie manually

        
        dictionary = new Trie();

        // dictionary.add("cat");
        // dictionary.add("car");
        // // dictionary.add("hat");
        // dictionary.add("averse");
        // dictionary.add("roar");
        // dictionary.add("roast");
        // dictionary.add("seem");
        // dictionary.add("severance");
        // dictionary.add("tee");
        //  dictionary.add("tie");
        dictionary.add("verse");
        // dictionary.add("ever");
        // dictionary.add("everest");
        // dictionary.add("everybody");
        // dictionary.add("everywhere");
        // dictionary.add("events");
        // dictionary.add("verse");
        // dictionary.add("verdant");
        // dictionary.add("ovens");
        

        // here is an example of calling functions to test the Trie

        //System.out.println(dictionary.contains("cat"));
        System.out.println(dictionary.suggestions("ever", 4));
    }
}
